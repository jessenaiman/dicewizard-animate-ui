{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "icons-icon",
  "type": "registry:ui",
  "title": "Icon",
  "description": "Base component to use animated icons.",
  "dependencies": [
    "motion"
  ],
  "registryDependencies": [
    "@animate-ui/hooks-use-is-in-view"
  ],
  "files": [
    {
      "path": "registry/icons/icon/index.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport {\n  SVGMotionProps,\n  useAnimation,\n  UseInViewOptions,\n  type LegacyAnimationControls,\n  type Variants,\n} from 'motion/react';\n\nimport { cn } from '@/lib/utils';\nimport { useIsInView } from '@/hooks/use-is-in-view';\n\nconst staticAnimations = {\n  path: {\n    initial: { pathLength: 1, opacity: 1 },\n    animate: {\n      pathLength: [0.05, 1],\n      opacity: [0, 1],\n      transition: {\n        duration: 0.8,\n        ease: 'easeInOut',\n        opacity: { duration: 0.01 },\n      },\n    },\n  } as Variants,\n  'path-loop': {\n    initial: { pathLength: 1, opacity: 1 },\n    animate: {\n      pathLength: [1, 0.05, 1],\n      opacity: [1, 0, 1],\n      transition: {\n        duration: 1.6,\n        ease: 'easeInOut',\n        opacity: { duration: 0.01 },\n      },\n    },\n  } as Variants,\n} as const;\n\ntype StaticAnimations = keyof typeof staticAnimations;\ntype TriggerProp<T = string> = boolean | StaticAnimations | T;\ntype Trigger = TriggerProp<string>;\n\ninterface AnimateIconContextValue {\n  controls: LegacyAnimationControls | undefined;\n  animation: StaticAnimations | string;\n  loop: boolean;\n  loopDelay: number;\n  active: boolean;\n  animate?: Trigger;\n  animateOnHover?: Trigger;\n  animateOnTap?: Trigger;\n  animateOnView?: Trigger;\n  animateOnViewMargin?: UseInViewOptions['margin'];\n  animateOnViewOnce?: boolean;\n  initialOnAnimateEnd?: boolean;\n  persistOnAnimateEnd?: boolean;\n  delay?: number;\n}\n\ninterface DefaultIconProps<T = string> {\n  animate?: TriggerProp<T>;\n  onAnimateChange?: (\n    value: boolean,\n    animation: StaticAnimations | string,\n  ) => void;\n  animateOnHover?: TriggerProp<T>;\n  animateOnTap?: TriggerProp<T>;\n  animateOnView?: TriggerProp<T>;\n  animateOnViewMargin?: UseInViewOptions['margin'];\n  animateOnViewOnce?: boolean;\n  animation?: T | StaticAnimations;\n  loop?: boolean;\n  loopDelay?: number;\n  onAnimateStart?: () => void;\n  onAnimateEnd?: () => void;\n  initialOnAnimateEnd?: boolean;\n  persistOnAnimateEnd?: boolean;\n  delay?: number;\n}\n\ninterface AnimateIconProps<T = string> extends DefaultIconProps<T> {\n  children: React.ReactNode;\n  asChild?: boolean;\n}\n\ninterface IconProps<T>\n  extends DefaultIconProps<T>,\n    Omit<\n      SVGMotionProps<SVGSVGElement>,\n      'animate' | 'onAnimationStart' | 'onAnimationEnd'\n    > {\n  size?: number;\n}\n\ninterface IconWrapperProps<T> extends IconProps<T> {\n  icon: React.ComponentType<IconProps<T>>;\n}\n\nconst AnimateIconContext = React.createContext<AnimateIconContextValue | null>(\n  null,\n);\n\nfunction useAnimateIconContext() {\n  const context = React.useContext(AnimateIconContext);\n  if (!context)\n    return {\n      controls: undefined,\n      animation: 'default',\n      loop: false,\n      loopDelay: 0,\n      active: false,\n      animate: undefined,\n      animateOnHover: undefined,\n      animateOnTap: undefined,\n      animateOnView: undefined,\n      animateOnViewMargin: '0px' as UseInViewOptions['margin'],\n      animateOnViewOnce: true,\n      initialOnAnimateEnd: false,\n      persistOnAnimateEnd: false,\n      delay: 0,\n    };\n  return context;\n}\n\nfunction composeEventHandlers<E extends React.SyntheticEvent<unknown>>(\n  theirs?: (event: E) => void,\n  ours?: (event: E) => void,\n) {\n  return (event: E) => {\n    theirs?.(event);\n    ours?.(event);\n  };\n}\n\nfunction mergeRefs<T>(...refs: Array<React.Ref<T> | undefined>) {\n  return (value: T) => {\n    for (const ref of refs) {\n      if (!ref) continue;\n      if (typeof ref === 'function') ref(value);\n      else (ref as React.MutableRefObject<T | null>).current = value;\n    }\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyProps = Record<string, any>;\n\ntype SlotProps<E extends Element = HTMLElement> = {\n  children: React.ReactElement;\n} & React.HTMLAttributes<E> &\n  AnyProps;\n\nfunction Slot<E extends Element = HTMLElement>({\n  children,\n  ...slotProps\n}: SlotProps<E>) {\n  if (!React.isValidElement(children)) return children;\n\n  const {\n    className: slotClassName,\n    style: slotStyle,\n    ref: slotRef,\n    onMouseEnter: sOnMouseEnter,\n    onMouseLeave: sOnMouseLeave,\n    onPointerDown: sOnPointerDown,\n    onPointerUp: sOnPointerUp,\n    ...restSlot\n  } = slotProps;\n\n  const {\n    className: childClassName,\n    style: childStyle,\n    ref: childRef,\n    onMouseEnter: cOnMouseEnter,\n    onMouseLeave: cOnMouseLeave,\n    onPointerDown: cOnPointerDown,\n    onPointerUp: cOnPointerUp,\n    ...restChild\n  } = (children.props ?? {}) as AnyProps;\n\n  const mergedProps: AnyProps = {\n    ...restChild,\n    ...restSlot,\n    className: cn(childClassName, slotClassName),\n    style: { ...(childStyle || {}), ...(slotStyle || {}) },\n    ref: mergeRefs(childRef, slotRef),\n    onMouseEnter: composeEventHandlers(cOnMouseEnter, sOnMouseEnter),\n    onMouseLeave: composeEventHandlers(cOnMouseLeave, sOnMouseLeave),\n    onPointerDown: composeEventHandlers(cOnPointerDown, sOnPointerDown),\n    onPointerUp: composeEventHandlers(cOnPointerUp, sOnPointerUp),\n  };\n\n  return React.cloneElement(children, mergedProps);\n}\n\nfunction AnimateIcon({\n  animate,\n  onAnimateChange,\n  asChild = true,\n  animateOnHover,\n  animateOnTap,\n  animateOnView,\n  animateOnViewMargin = '0px',\n  animateOnViewOnce = true,\n  animation = 'default',\n  loop = false,\n  loopDelay = 0,\n  onAnimateStart,\n  onAnimateEnd,\n  initialOnAnimateEnd = false,\n  persistOnAnimateEnd = false,\n  delay = 0,\n  children,\n}: AnimateIconProps) {\n  const controls = useAnimation();\n\n  const [localAnimate, setLocalAnimate] = React.useState<boolean>(() => {\n    if (animate === undefined || animate === false) return false;\n    return delay <= 0;\n  });\n  const [currentAnimation, setCurrentAnimation] = React.useState<\n    string | StaticAnimations\n  >(typeof animate === 'string' ? animate : animation);\n  const [status, setStatus] = React.useState<'initial' | 'animate'>('initial');\n\n  const delayRef = React.useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  const startAnimation = React.useCallback(\n    (trigger: TriggerProp) => {\n      const next = typeof trigger === 'string' ? trigger : animation;\n      if (delayRef.current) {\n        clearTimeout(delayRef.current);\n        delayRef.current = null;\n      }\n      setCurrentAnimation(next);\n      if (delay > 0) {\n        setLocalAnimate(false);\n        delayRef.current = setTimeout(() => {\n          setLocalAnimate(true);\n        }, delay);\n      } else {\n        setLocalAnimate(true);\n      }\n    },\n    [animation, delay],\n  );\n\n  const stopAnimation = React.useCallback(() => {\n    if (delayRef.current) {\n      clearTimeout(delayRef.current);\n      delayRef.current = null;\n    }\n    setLocalAnimate(false);\n  }, []);\n\n  React.useEffect(() => {\n    if (animate === undefined) return;\n    setCurrentAnimation(typeof animate === 'string' ? animate : animation);\n    if (animate) startAnimation(animate as TriggerProp);\n    else stopAnimation();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [animate]);\n\n  React.useEffect(\n    () => onAnimateChange?.(localAnimate, currentAnimation),\n    [localAnimate, onAnimateChange, currentAnimation],\n  );\n\n  React.useEffect(() => {\n    return () => {\n      if (delayRef.current) clearTimeout(delayRef.current);\n    };\n  }, []);\n\n  const viewOuterRef = React.useRef<HTMLElement>(null);\n  const { ref: inViewRef, isInView } = useIsInView(viewOuterRef, {\n    inView: !!animateOnView,\n    inViewOnce: animateOnViewOnce,\n    inViewMargin: animateOnViewMargin,\n  });\n\n  React.useEffect(() => {\n    if (!animateOnView) return;\n    if (isInView) startAnimation(animateOnView);\n    else stopAnimation();\n  }, [isInView, animateOnView, startAnimation, stopAnimation]);\n\n  React.useEffect(() => {\n    async function run() {\n      if (!localAnimate) {\n        if (!persistOnAnimateEnd) {\n          controls.start('initial');\n          setStatus('initial');\n        }\n        return;\n      }\n\n      if (status !== 'initial' && persistOnAnimateEnd) {\n        controls.set('initial');\n        setStatus('initial');\n      }\n\n      onAnimateStart?.();\n\n      try {\n        await controls.start('animate');\n        setStatus('animate');\n      } catch {\n        return;\n      }\n\n      onAnimateEnd?.();\n\n      if (initialOnAnimateEnd || loop) {\n        try {\n          controls.set('initial');\n          setStatus('initial');\n        } catch {\n          return;\n        }\n      }\n      if (loop) {\n        if (loopDelay > 0) {\n          await new Promise((r) => setTimeout(r, loopDelay));\n        }\n        await run();\n      }\n    }\n\n    void run();\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [localAnimate, controls]);\n\n  const childProps = (\n    React.isValidElement(children) ? (children as React.ReactElement).props : {}\n  ) as AnyProps;\n\n  const handleMouseEnter = composeEventHandlers<React.MouseEvent<HTMLElement>>(\n    childProps.onMouseEnter,\n    () => {\n      if (animateOnHover) startAnimation(animateOnHover);\n    },\n  );\n\n  const handleMouseLeave = composeEventHandlers<React.MouseEvent<HTMLElement>>(\n    childProps.onMouseLeave,\n    () => {\n      if (animateOnHover || animateOnTap) stopAnimation();\n    },\n  );\n\n  const handlePointerDown = composeEventHandlers<\n    React.PointerEvent<HTMLElement>\n  >(childProps.onPointerDown, () => {\n    if (animateOnTap) startAnimation(animateOnTap);\n  });\n\n  const handlePointerUp = composeEventHandlers<React.PointerEvent<HTMLElement>>(\n    childProps.onPointerUp,\n    () => {\n      if (animateOnTap) stopAnimation();\n    },\n  );\n\n  const content = asChild ? (\n    <Slot\n      ref={inViewRef}\n      onMouseEnter={handleMouseEnter}\n      onMouseLeave={handleMouseLeave}\n      onPointerDown={handlePointerDown}\n      onPointerUp={handlePointerUp}\n    >\n      {children as React.ReactElement}\n    </Slot>\n  ) : (\n    <span\n      ref={inViewRef}\n      onMouseEnter={handleMouseEnter}\n      onMouseLeave={handleMouseLeave}\n      onPointerDown={handlePointerDown}\n      onPointerUp={handlePointerUp}\n      style={{ display: 'contents' }}\n    >\n      {children}\n    </span>\n  );\n\n  return (\n    <AnimateIconContext.Provider\n      value={{\n        controls,\n        animation: currentAnimation,\n        loop,\n        loopDelay,\n        active: localAnimate,\n        animate,\n        animateOnHover,\n        animateOnTap,\n        animateOnView,\n        animateOnViewMargin,\n        animateOnViewOnce,\n        initialOnAnimateEnd,\n        delay,\n      }}\n    >\n      {content}\n    </AnimateIconContext.Provider>\n  );\n}\n\nconst pathClassName =\n  \"[&_[stroke-dasharray='1px_1px']]:![stroke-dasharray:1px_0px]\";\n\nfunction IconWrapper<T extends string>({\n  size = 28,\n  animation: animationProp,\n  animate,\n  onAnimateChange,\n  animateOnHover = false,\n  animateOnTap = false,\n  animateOnView = false,\n  animateOnViewMargin = '0px',\n  animateOnViewOnce = true,\n  icon: IconComponent,\n  loop = false,\n  loopDelay = 0,\n  onAnimateStart,\n  onAnimateEnd,\n  initialOnAnimateEnd = false,\n  delay = 0,\n  className,\n  ...props\n}: IconWrapperProps<T>) {\n  const context = React.useContext(AnimateIconContext);\n\n  if (context) {\n    const {\n      controls,\n      animation: parentAnimation,\n      loop: parentLoop,\n      loopDelay: parentLoopDelay,\n      active: parentActive,\n      animate: parentAnimate,\n      animateOnHover: parentAnimateOnHover,\n      animateOnTap: parentAnimateOnTap,\n      animateOnView: parentAnimateOnView,\n      animateOnViewMargin: parentAnimateOnViewMargin,\n      animateOnViewOnce: parentAnimateOnViewOnce,\n      initialOnAnimateEnd: parentInitialOnAnimateEnd,\n      delay: parentDelay,\n    } = context;\n\n    const hasOverrides =\n      animate !== undefined ||\n      animationProp !== undefined ||\n      animateOnHover !== false ||\n      animateOnTap !== false ||\n      animateOnView !== false ||\n      loop !== false ||\n      loopDelay !== 0 ||\n      initialOnAnimateEnd !== false ||\n      delay !== 0;\n\n    if (hasOverrides) {\n      const inheritedAnimate: Trigger = parentActive\n        ? (animationProp ?? parentAnimation ?? 'default')\n        : false;\n\n      const finalAnimate: Trigger = (animate ??\n        parentAnimate ??\n        inheritedAnimate) as Trigger;\n\n      return (\n        <AnimateIcon\n          animate={finalAnimate}\n          animateOnHover={animateOnHover ?? parentAnimateOnHover}\n          animateOnTap={animateOnTap ?? parentAnimateOnTap}\n          animateOnView={animateOnView ?? parentAnimateOnView}\n          animateOnViewMargin={animateOnViewMargin ?? parentAnimateOnViewMargin}\n          animateOnViewOnce={animateOnViewOnce ?? parentAnimateOnViewOnce}\n          animation={animationProp ?? parentAnimation}\n          loop={loop ?? parentLoop}\n          loopDelay={loopDelay ?? parentLoopDelay}\n          onAnimateChange={onAnimateChange}\n          onAnimateStart={onAnimateStart}\n          onAnimateEnd={onAnimateEnd}\n          initialOnAnimateEnd={initialOnAnimateEnd ?? parentInitialOnAnimateEnd}\n          delay={delay ?? parentDelay}\n          asChild\n        >\n          <IconComponent\n            size={size}\n            className={cn(\n              className,\n              ((animationProp ?? parentAnimation) === 'path' ||\n                (animationProp ?? parentAnimation) === 'path-loop') &&\n                pathClassName,\n            )}\n            {...props}\n          />\n        </AnimateIcon>\n      );\n    }\n\n    const animationToUse = animationProp ?? parentAnimation;\n    const loopToUse = parentLoop;\n    const loopDelayToUse = parentLoopDelay;\n\n    return (\n      <AnimateIconContext.Provider\n        value={{\n          controls,\n          animation: animationToUse,\n          loop: loopToUse,\n          loopDelay: loopDelayToUse,\n          active: parentActive,\n          animate: parentAnimate,\n          animateOnHover: parentAnimateOnHover,\n          animateOnTap: parentAnimateOnTap,\n          animateOnView: parentAnimateOnView,\n          animateOnViewMargin: parentAnimateOnViewMargin,\n          animateOnViewOnce: parentAnimateOnViewOnce,\n          initialOnAnimateEnd: parentInitialOnAnimateEnd,\n          delay: parentDelay,\n        }}\n      >\n        <IconComponent\n          size={size}\n          className={cn(\n            className,\n            (animationToUse === 'path' || animationToUse === 'path-loop') &&\n              pathClassName,\n          )}\n          {...props}\n        />\n      </AnimateIconContext.Provider>\n    );\n  }\n\n  if (\n    animate !== undefined ||\n    onAnimateChange !== undefined ||\n    animateOnHover ||\n    animateOnTap ||\n    animateOnView ||\n    animationProp\n  ) {\n    return (\n      <AnimateIcon\n        animate={animate}\n        onAnimateChange={onAnimateChange}\n        animateOnHover={animateOnHover}\n        animateOnTap={animateOnTap}\n        animateOnView={animateOnView}\n        animateOnViewMargin={animateOnViewMargin}\n        animateOnViewOnce={animateOnViewOnce}\n        animation={animationProp}\n        loop={loop}\n        loopDelay={loopDelay}\n        onAnimateStart={onAnimateStart}\n        onAnimateEnd={onAnimateEnd}\n        delay={delay}\n        asChild\n      >\n        <IconComponent\n          size={size}\n          className={cn(\n            className,\n            (animationProp === 'path' || animationProp === 'path-loop') &&\n              pathClassName,\n          )}\n          {...props}\n        />\n      </AnimateIcon>\n    );\n  }\n\n  return (\n    <IconComponent\n      size={size}\n      className={cn(\n        className,\n        (animationProp === 'path' || animationProp === 'path-loop') &&\n          pathClassName,\n      )}\n      {...props}\n    />\n  );\n}\n\nfunction getVariants<\n  V extends { default: T; [key: string]: T },\n  T extends Record<string, Variants>,\n>(animations: V): T {\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const { animation: animationType } = useAnimateIconContext();\n\n  let result: T;\n\n  if (animationType in staticAnimations) {\n    const variant = staticAnimations[animationType as StaticAnimations];\n    result = {} as T;\n    for (const key in animations.default) {\n      if (\n        (animationType === 'path' || animationType === 'path-loop') &&\n        key.includes('group')\n      )\n        continue;\n      result[key] = variant as T[Extract<keyof T, string>];\n    }\n  } else {\n    result = (animations[animationType as keyof V] as T) ?? animations.default;\n  }\n\n  return result;\n}\n\nexport {\n  pathClassName,\n  staticAnimations,\n  AnimateIcon,\n  IconWrapper,\n  useAnimateIconContext,\n  getVariants,\n  type IconProps,\n  type IconWrapperProps,\n  type AnimateIconProps,\n  type AnimateIconContextValue,\n};\n",
      "type": "registry:ui",
      "target": "components/animate-ui/icons/icon.tsx"
    }
  ]
}