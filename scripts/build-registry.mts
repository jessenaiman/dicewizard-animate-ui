/* eslint-disable @typescript-eslint/no-explicit-any */

import { exec } from 'child_process';
import { promises as fs } from 'fs';
import path from 'path';
import { rimraf } from 'rimraf';
import { AUTO_REGISTRY_DIR_NAME, REGISTRY_DIR, Styles } from './constants.mts';

/**
 * Normalize a path to use forward slashes.
 * @param inputPath - The input path to normalize.
 * @returns The normalized path with forward slashes.
 */
function normalizePath(inputPath: string): string {
  return inputPath.replace(/\\/g, '/');
}
/**
 * Replace registry paths with component paths.
 * @param inputStr - The input string to process.
 * @returns The processed string with registry paths replaced.
 */
export function replaceRegistryPaths(inputStr: string): string {
  const registryPrefix = '@/__registry__/';
  return inputStr.replace(/(['"])([\s\S]*?)\1/g, (match, quote, content) => {
    if (content.startsWith(registryPrefix)) {
      const rest = content.slice(registryPrefix.length);
      const segments = rest.split('/');
      if (segments.length >= 2) {
        const newPath = segments.slice(0, -1).join('/');
        return `${quote}@/components/animate-ui/${newPath}${quote}`;
      }
    }
    return match;
  });
}

function extractStyleVariants(meta?: {
  styles?: Record<string, any> | string[];
}): string[] | undefined {
  const styles = meta?.styles;

  if (styles && typeof styles === 'object') {
    return Object.keys(styles);
  }

  return undefined;
}

/**
 * Recursively search for registry-item.json files in a given directory.
 * @param dir - Directory to search in.
 * @returns An array of registry item objects.
 */
async function getRegistryItemsFromFolder(
  dir: string,
): Promise<Record<Styles, any[]>> {
  const items = {} as Record<Styles, any[]>;
  for (const style of Object.values(Styles)) {
    items[style] = [];
  }

  const entries = await fs.readdir(dir, { withFileTypes: true });

  for (const entry of entries) {
    // Skip the autogenerated folder entirely
    if (entry.isDirectory() && entry.name === AUTO_REGISTRY_DIR_NAME) {
      continue;
    }

    const fullPath = path.join(dir, entry.name);
    if (!entry.isDirectory()) {
      continue;
    }

    const jsonPath = path.join(fullPath, 'registry-item.json');
    try {
      await fs.access(jsonPath);
      const raw = await fs.readFile(jsonPath, 'utf-8');
      const item = JSON.parse(raw);

      if (item.$schema) {
        delete item.$schema;
      }

      // Expand one item per style
      for (const style of Object.values(Styles)) {
        const relDir = path.relative(REGISTRY_DIR, fullPath);
        const relOutDir = path.posix.join(
          AUTO_REGISTRY_DIR_NAME,
          relDir,
          style,
        );
        const newPath = path.posix.join(relOutDir, 'index.tsx');

        // Clone and adjust item
        const clone = {
          ...item,
          files: [
            {
              path: newPath,
              type: item.files[0].type,
              target: item.files[0].target,
            },
          ],
        };

        if (Array.isArray(item.registryDependencies)) {
          clone.registryDependencies = item.registryDependencies.map(
            (url: string) => {
              const m = url.match(
                /^https:\/\/animate-ui\.com\/r\/([^\/]+)\/?$/,
              );
              if (m) {
                return `https://animate-ui.com/r/${style}/${m[1]}`;
              }
              return url;
            },
          );
        }

        items[style].push(clone);
      }
    } catch {
      // no registry-item.json here ‚Üí descend one level
      const subItems = await getRegistryItemsFromFolder(fullPath);
      for (const style of Object.values(Styles)) {
        items[style].push(...subItems[style]);
      }
    }
  }

  return items;
}

/**
 * Function to build the merged registry.json file.
 * It searches for all registry-item.json files in the registry directory,
 * removes the $schema property, and merges them into the base registry.json items array.
 */
async function buildRegistryFile() {
  const registryFolderPath = path.join(process.cwd(), 'registry');
  const newItemsByStyle = await getRegistryItemsFromFolder(registryFolderPath);

  const outRoot = path.join(process.cwd(), 'registry-json');
  const baseIndexItem = {
    name: 'index',
    type: 'registry:style',
    dependencies: [
      'tailwindcss-animate',
      'class-variance-authority',
      'lucide-react',
    ],
    registryDependencies: ['utils'],
    files: [],
    tailwind: {
      config: { plugins: ['require("tailwindcss-animate")'] },
    },
    cssVars: {},
  };

  // read all existing style-JSON files
  const files = await fs.readdir(outRoot);
  for (const file of files) {
    if (!file.endsWith('.json')) continue;
    const style = path.basename(file, '.json');
    const filePath = path.join(outRoot, file);

    // load current JSON
    const raw = await fs.readFile(filePath, 'utf-8');
    const data = JSON.parse(raw);

    // replace items array
    data.items = [baseIndexItem, ...(newItemsByStyle[style as Styles] || [])];

    // write back
    await fs.writeFile(filePath, JSON.stringify(data, null, 2));
  }
}

/**
 * Function to build the registry index file.
 * This function reads the registry.json items and builds a dynamic index file.
 */
async function buildRegistryIndex() {
  const stylesDir = path.join(process.cwd(), 'registry-json');
  const files = await fs.readdir(stylesDir);

  let indexFile = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"
import type { Styles } from '@/constants';

export const index: Record<Styles, Record<string, any>> = {`;

  for (const file of files) {
    if (!file.endsWith('.json')) continue;
    const style = path.basename(file, '.json');
    const stylePath = path.join(stylesDir, file);
    const raw = await fs.readFile(stylePath, 'utf-8');
    const data = JSON.parse(raw);

    indexFile += `\n  "${style}": {`;

    // dedupe by name, keep last
    const unique = new Map<string, (typeof data.items)[0]>();
    for (const item of data.items) {
      unique.set(item.name, item);
    }

    for (const item of unique.values()) {
      if (!item.files) continue;
      const componentPath = item.files[0]?.path
        ? `@/${item.files[0].path}`
        : '';
      const filesWithContent = await Promise.all(
        item.files.map(async (f: any) => {
          const p = typeof f === 'string' ? f : f.path;
          try {
            const content = await fs.readFile(path.resolve(p), 'utf-8');
            return {
              path: p,
              type: f.type ?? 'unknown',
              target: f.target ?? '',
              content: replaceRegistryPaths(content).trim(),
            };
          } catch {
            return {
              path: p,
              type: f.type ?? 'unknown',
              target: f.target ?? '',
              content: '',
            };
          }
        }),
      );

      const compSnippet = componentPath
        ? `(function() {
      const LazyComp = React.lazy(async () => {
        const mod = await import("${normalizePath(componentPath)}")
        const exportName = Object.keys(mod).find(
          key => typeof mod[key] === 'function' || typeof mod[key] === 'object'
        ) || "${item.name}"
        const Comp = mod.default || mod[exportName]
        return { default: Comp }
      })
      LazyComp.demoProps = ${JSON.stringify(item?.meta?.demoProps ?? {})}
      return LazyComp
    })()`
        : 'null';

      indexFile += `
    "${item.name}": {
      name: ${JSON.stringify(item.name)},
      description: ${JSON.stringify(item.description ?? '')},
      type: "${item.type}",
      dependencies: ${JSON.stringify(item.dependencies)},
      devDependencies: ${JSON.stringify(item.devDependencies)},
      registryDependencies: ${JSON.stringify(item.registryDependencies)},
      styles: ${JSON.stringify(extractStyleVariants(item.meta))},
      files: ${JSON.stringify(filesWithContent, null, 2)},
      component: ${compSnippet},
      command: 'https://animate-ui.com/r/${style}/${item.name}',
    },`;
    }

    indexFile += `
  },`;
  }

  indexFile += `
}`;

  rimraf.sync(path.join(process.cwd(), '__registry__/index.tsx'));
  await fs.writeFile(
    path.join(process.cwd(), '__registry__/index.tsx'),
    indexFile,
  );
}

/**
 * Function to build the registry.
 * It clears the previous registry directory, builds the registry files,
 * and replaces specific path strings in the generated files.
 */
async function buildRegistry() {
  // 1. Remove the previous registry directory
  const registryDir = path.join(process.cwd(), 'public/r');
  await fs.rm(registryDir, { recursive: true, force: true });
  await fs.mkdir(registryDir, { recursive: true });

  // 2. For each style JSON, run shadcn build into public/r/<style>
  const stylesDir = path.join(process.cwd(), 'registry-json');
  const styleFiles = await fs.readdir(stylesDir);
  for (const file of styleFiles) {
    if (!file.endsWith('.json')) continue;
    const style = path.basename(file, '.json');
    const inputJson = path.join(stylesDir, file);
    const outputDir = path.join(registryDir, style);
    await fs.mkdir(outputDir, { recursive: true });

    await new Promise<void>((resolve, reject) => {
      const proc = exec(
        `pnpm dlx shadcn build ${inputJson} --output ${outputDir}`,
      );
      proc.on('exit', (code) => {
        if (code === 0) resolve();
        else
          reject(
            new Error(`Shadcn build for ${style} exited with code ${code}`),
          );
      });
    });

    // 3. Replace `@/__registry__/` paths in every generated file
    const builtFiles = await fs.readdir(outputDir);
    await Promise.all(
      builtFiles.map(async (f) => {
        const fpath = path.join(outputDir, f);
        const raw = await fs.readFile(fpath, 'utf-8');
        const registryItem = JSON.parse(raw);
        registryItem.files = registryItem.files?.map((item: any) => {
          if (item.content?.includes('@/__registry__/')) {
            item.content = replaceRegistryPaths(item.content);
          }
          return item;
        });
        await fs.writeFile(fpath, JSON.stringify(registryItem, null, 2));
      }),
    );
  }
}

// Execute the build process in the following order:
// 1. Build the merged registry.json file with new items from registry-item.json files.
// 2. Build the registry index.
// 3. Build the registry.
try {
  console.log('üî® Building merged registry file...');
  await buildRegistryFile();
  console.log('üóÇÔ∏è Building registry/__index__.tsx...');
  await buildRegistryIndex();
  console.log('üèóÔ∏è Building registry...');
  await buildRegistry();
  console.log('üéâ Registry build completed successfully!');
} catch (error) {
  console.error(error);
  process.exit(1);
}
