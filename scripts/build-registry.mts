/* eslint-disable @typescript-eslint/no-explicit-any */

import { exec } from 'child_process';
import { promises as fs } from 'fs';
import path from 'path';
import { rimraf } from 'rimraf';
import {
  AUTO_REGISTRY_DIR_NAME,
  REGISTRY_DIR,
  REGISTRY_JSON_DIR,
  REGISTRY_JSON_NAME,
  Styles,
} from './constants.mts';

/**
 * Normalize a path to use forward slashes.
 * @param inputPath - The input path to normalize.
 * @returns The normalized path with forward slashes.
 */
function normalizePath(inputPath: string): string {
  return inputPath.replace(/\\/g, '/');
}
/**
 * Replace registry paths with component paths.
 * @param inputStr - The input string to process.
 * @returns The processed string with registry paths replaced.
 */
export function replaceRegistryPaths(inputStr: string): string {
  const registryPrefix = '@/__registry__/';
  return inputStr.replace(/(['"])([\s\S]*?)\1/g, (match, quote, content) => {
    if (content.startsWith(registryPrefix)) {
      const rest = content.slice(registryPrefix.length);
      const segments = rest.split('/');
      if (segments.length >= 2) {
        const newPath = segments.slice(0, -1).join('/');
        return `${quote}@/components/animate-ui/${newPath}${quote}`;
      }
    }
    return match;
  });
}

function extractStyleVariants(meta?: {
  styles?: Record<string, any> | string[];
}): string[] | undefined {
  const styles = meta?.styles;

  if (styles && typeof styles === 'object') {
    return Object.keys(styles);
  }

  return undefined;
}

function formatText(text: string, style: Styles) {
  const base = text.replace(/\.\s*$/, '');
  return `${base} with ${style} style.`;
}

/**
 * Recursively search for registry-item.json files in a given directory.
 * @param dir - Directory to search in.
 * @returns An array of registry item objects.
 */
async function getRegistryItemsFromFolder(dir: string): Promise<any[]> {
  const items = [] as any[];

  const entries = await fs.readdir(dir, { withFileTypes: true });

  for (const entry of entries) {
    // Skip the autogenerated folder entirely
    if (entry.isDirectory() && entry.name === AUTO_REGISTRY_DIR_NAME) {
      continue;
    }

    const fullPath = path.join(dir, entry.name);
    if (!entry.isDirectory()) {
      continue;
    }

    const jsonPath = path.join(fullPath, 'registry-item.json');
    try {
      await fs.access(jsonPath);
      const raw = await fs.readFile(jsonPath, 'utf-8');
      const item = JSON.parse(raw);

      if (item.$schema) {
        delete item.$schema;
      }

      // Expand one item per style
      for (const style of Object.values(Styles)) {
        const relDir = path.relative(REGISTRY_DIR, fullPath);
        const relOutDir = path.posix.join(
          AUTO_REGISTRY_DIR_NAME,
          relDir,
          style,
        );
        const newPath = path.posix.join(relOutDir, 'index.tsx');

        // Clone and adjust item
        const clone = {
          ...item,
          name: `${style}-${item.name}`,
          description: formatText(item.description, style),
          files: [
            {
              path: newPath,
              type: item.files[0].type,
              target: item.files[0].target,
            },
          ],
        };

        if (Array.isArray(item.registryDependencies)) {
          clone.registryDependencies = item.registryDependencies.map(
            (url: string) => {
              const m = url.match(
                /^https:\/\/animate-ui\.com\/r\/([^\/]+)\/?$/,
              );
              if (m) {
                return `https://animate-ui.com/r/${style}-${m[1]}`;
              }
              return url;
            },
          );
        }

        items.push(clone);
      }
    } catch {
      // no registry-item.json here ‚Üí descend one level
      const subItems = await getRegistryItemsFromFolder(fullPath);
      items.push(...subItems);
    }
  }

  return items;
}

/**
 * Function to build the merged registry.json file.
 * It searches for all registry-item.json files in the registry directory,
 * removes the $schema property, and merges them into the base registry.json items array.
 */
async function buildRegistryFile() {
  const registryFolderPath = path.join(process.cwd(), 'registry');
  const newItemsByStyle = await getRegistryItemsFromFolder(registryFolderPath);

  const baseIndexItem = {
    name: 'index',
    type: 'registry:style',
    dependencies: [
      'tw-animate-css',
      'class-variance-authority',
      'lucide-react',
    ],
    registryDependencies: ['utils'],
    files: [],
    cssVars: {},
  };

  const outputPath = path.join(REGISTRY_JSON_DIR, REGISTRY_JSON_NAME);
  const raw = await fs.readFile(outputPath, 'utf-8');
  const data = JSON.parse(raw);
  data.items = [baseIndexItem, ...(newItemsByStyle || [])];
  await fs.writeFile(outputPath, JSON.stringify(data, null, 2));
}

/**
 * Function to build the registry index file.
 * This function reads the flat registry.json and builds a dynamic index file.
 */
async function buildRegistryIndex() {
  const registryPath = path.join(REGISTRY_JSON_DIR, REGISTRY_JSON_NAME);
  const rawRegistry = await fs.readFile(registryPath, 'utf-8');
  const registryData = JSON.parse(rawRegistry);

  // start building the index file
  let indexFile = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react";

export const index: Record<string, any> = {`;

  // dedupe by name, keep last occurrence
  const unique = new Map<string, (typeof registryData.items)[0]>();
  for (const item of registryData.items) {
    unique.set(item.name, item);
  }

  for (const item of unique.values()) {
    if (!item.files) continue;

    const componentPath = item.files[0]?.path ? `@/${item.files[0].path}` : '';

    // read file contents for each entry
    const filesWithContent = await Promise.all(
      item.files.map(async (f: any) => {
        const p = typeof f === 'string' ? f : f.path;
        try {
          const content = await fs.readFile(path.resolve(p), 'utf-8');
          return {
            path: p,
            type: f.type ?? 'unknown',
            target: f.target ?? '',
            content: replaceRegistryPaths(content).trim(),
          };
        } catch {
          return {
            path: p,
            type: f.type ?? 'unknown',
            target: f.target ?? '',
            content: '',
          };
        }
      }),
    );

    const compSnippet = componentPath
      ? `(function() {
      const LazyComp = React.lazy(async () => {
        const mod = await import("${normalizePath(componentPath)}")
        const exportName = Object.keys(mod).find(
          key => typeof mod[key] === 'function' || typeof mod[key] === 'object'
        ) || "${item.name}"
        const Comp = mod.default || mod[exportName]
        return { default: Comp }
      })
      LazyComp.demoProps = ${JSON.stringify(item?.meta?.demoProps ?? {})}
      return LazyComp
    })()`
      : 'null';

    indexFile += `
  "${item.name}": {
    name: ${JSON.stringify(item.name)},
    description: ${JSON.stringify(item.description ?? '')},
    type: "${item.type}",
    dependencies: ${JSON.stringify(item.dependencies)},
    devDependencies: ${JSON.stringify(item.devDependencies)},
    registryDependencies: ${JSON.stringify(item.registryDependencies)},
    styles: ${JSON.stringify(extractStyleVariants(item.meta))},
    files: ${JSON.stringify(filesWithContent, null, 2)},
    component: ${compSnippet},
    command: "https://animate-ui.com/r/${item.name}",
  },`;
  }

  indexFile += `
};`;

  // remove old index and write the new one
  rimraf.sync(path.join(process.cwd(), '__registry__/index.tsx'));
  await fs.writeFile(
    path.join(process.cwd(), '__registry__/index.tsx'),
    indexFile,
  );
}

/**
 * Function to build the registry.
 * It clears the previous registry directory, builds all items from the single registry.json,
 * and replaces specific path strings in the generated files.
 */
async function buildRegistry() {
  // 1. Ensure registryDir exists
  await fs.mkdir(REGISTRY_JSON_DIR, { recursive: true });

  // 2. Remove everything except registry.json
  const entries = await fs.readdir(REGISTRY_JSON_DIR);
  await Promise.all(
    entries.map(async (entry) => {
      if (entry === REGISTRY_JSON_NAME) return;
      const entryPath = path.join(REGISTRY_JSON_DIR, entry);
      await fs.rm(entryPath, { recursive: true, force: true });
    }),
  );

  // 3. Run shadcn build on the single registry.json
  const inputJson = path.join(REGISTRY_JSON_DIR, REGISTRY_JSON_NAME);
  await new Promise<void>((resolve, reject) => {
    const proc = exec(
      `pnpm dlx shadcn build ${inputJson} --output ${REGISTRY_JSON_DIR}`,
    );
    proc.on('exit', (code) => {
      if (code === 0) resolve();
      else reject(new Error(`Shadcn build exited with code ${code}`));
    });
  });

  // 3. Replace `@/__registry__/` paths in every generated file
  const builtFiles = await fs.readdir(REGISTRY_JSON_DIR);
  await Promise.all(
    builtFiles.map(async (f) => {
      const fpath = path.join(REGISTRY_JSON_DIR, f);
      const raw = await fs.readFile(fpath, 'utf-8');
      const registryItem = JSON.parse(raw);
      registryItem.files = registryItem.files?.map((item: any) => {
        if (item.content?.includes('@/__registry__/')) {
          item.content = replaceRegistryPaths(item.content);
        }
        return item;
      });
      await fs.writeFile(fpath, JSON.stringify(registryItem, null, 2));
    }),
  );
}

// Execute the build process in the following order:
// 1. Build the merged registry.json file with new items from registry-item.json files.
// 2. Build the registry index.
// 3. Build the registry.
try {
  console.log('üî® Building merged registry.json file...');
  await buildRegistryFile();
  console.log('üóÇÔ∏è Building __registry__/index.tsx...');
  await buildRegistryIndex();
  console.log('üèóÔ∏è Building registry...');
  await buildRegistry();
  console.log('üéâ Registry build completed successfully!');
} catch (error) {
  console.error(error);
  process.exit(1);
}
